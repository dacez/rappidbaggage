# Baggage 性能优化
## 一. 测试基准
性能评估: Bytes/s , 每秒处理的数据量

参考系: RapidJSON , SIMDJSON , Protobuf , msgpack(待定) 

数据格式: Key : Value   

节点格式: 4 8 64 180

## 二. 优化点
2.1 ThreadLocal 内存分配器 , 维护两个结构节点的队列 , Free 和 Alloced , 一次分配多个节点 ,  真正用的时候从 Free 拿 , 放到 Alloced 中 . 跟 go 1.13 的 sync.pool 类似 , 不过 sync.pool 太重 , 太慢 , C++ 可以实现 , Go 很难实现. 原因是 GC 或者 Free 内存消耗极大 .

2.2 半栈半堆 , 当栈大到一定程度的时候使用堆 , 小的时候用栈 . 前 64 个用栈 , 后面用堆 . 栈比堆消耗小很多 , C++ 好控制 , Go 相对难搞.

2.3 查表代替正则 , 表可以使用叠加是设计 , 由现在的 3 个表变 2 个表  , 甚至一个表 , 做到 L2 Cache 友好 . 

2.4 无内存拷贝 .

2.5 SplitN 使用 2.1 内存分配器分配的节点.

2.6 数组代替 Map 同样为了 L2 Cache 友好 , 当时大到一定程度的时候 , 用 Map 会更快 , Go 中的 map 代价太大 , 考虑的 Baggage 节点数有限 (180), 应该有更高效的索引方案 .

2.7 流水线优化 , 两步处理 , 第一步 , 分好节点 , 尽量做正确性判断 , 第二步 , 遍历节点 , 做最终正确性判断 . 循环体中每次处理 8 个节点 , 不能有判断语句 , 只有做完 8 个节点后可以判断

2.8 仿 SIMD 指令 , 用 uint64 一次操作 8 个 byte . 目前为了硬件兼容性 , 不考虑使用 SIMD

2.9 分支预测优化 _likely_ , Go 应该没法做

2.10 索引和计数变量使用寄存器 , 避免是使用 L2 Cache , 提高速度

2.11 GenOnChange 当需要改变是重新生成 , 跟 CopyOnWrite 类似

## 三. 工具
3.1 流水线 + 缓存 工具
3.2 内存统计
3.3 GC 观察
3.4 GO 反汇编工具

## 四. 结果
4.1 Go 版本的 Baggage + Benchmark
4.2 C++ 版本的 Baggage + Benchmark

